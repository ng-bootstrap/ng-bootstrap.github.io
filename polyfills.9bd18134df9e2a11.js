"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[429],{4663:(Kt,Kn,Zn)=>{Zn(8583);Error;const Vo=function(s,...e){if(Vo.translate){const n=Vo.translate(s,e);s=n[0],e=n[1]}let t=Gl(s[0],s.raw[0]);for(let n=1;n<s.length;n++)t+=e[n-1]+Gl(s[n],s.raw[n]);return t};function Gl(s,e){return":"===e.charAt(0)?s.substring(function Ul(s,e){for(let t=1,n=1;t<s.length;t++,n++)if("\\"===e[n])n++;else if(":"===s[t])return t;throw new Error(`Unterminated $localize metadata block in "${e}".`)}(s,e)+1):s}(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)().$localize=Vo},8583:()=>{!function(h){const v=h.performance;function x(T){v&&v.mark&&v.mark(T)}function _(T,W){v&&v.measure&&v.measure(T,W)}x("Zone");const C=h.__Zone_symbol_prefix||"__zone_symbol__";function I(T){return C+T}const M=!0===h[I("forceDuplicateZoneCheck")];if(h.Zone){if(M||"function"!=typeof h.Zone.__symbol__)throw new Error("Zone already loaded.");return h.Zone}let U=(()=>{class T{constructor(d,g){this._parent=d,this._name=g?g.name||"unnamed":"<root>",this._properties=g&&g.properties||{},this._zoneDelegate=new B(this,this._parent&&this._parent._zoneDelegate,g)}static assertZonePatched(){if(h.Promise!==Tt.ZoneAwarePromise)throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")}static get root(){let d=T.current;for(;d.parent;)d=d.parent;return d}static get current(){return Ne.zone}static get currentTask(){return gt}static __load_patch(d,g,k=!1){if(Tt.hasOwnProperty(d)){if(!k&&M)throw Error("Already loaded patch: "+d)}else if(!h["__Zone_disable_"+d]){const J="Zone:"+d;x(J),Tt[d]=g(h,T,be),_(J,J)}}get parent(){return this._parent}get name(){return this._name}get(d){const g=this.getZoneWith(d);if(g)return g._properties[d]}getZoneWith(d){let g=this;for(;g;){if(g._properties.hasOwnProperty(d))return g;g=g._parent}return null}fork(d){if(!d)throw new Error("ZoneSpec required!");return this._zoneDelegate.fork(this,d)}wrap(d,g){if("function"!=typeof d)throw new Error("Expecting function got: "+d);const k=this._zoneDelegate.intercept(this,d,g),J=this;return function(){return J.runGuarded(k,this,arguments,g)}}run(d,g,k,J){Ne={parent:Ne,zone:this};try{return this._zoneDelegate.invoke(this,d,g,k,J)}finally{Ne=Ne.parent}}runGuarded(d,g=null,k,J){Ne={parent:Ne,zone:this};try{try{return this._zoneDelegate.invoke(this,d,g,k,J)}catch(Me){if(this._zoneDelegate.handleError(this,Me))throw Me}}finally{Ne=Ne.parent}}runTask(d,g,k){if(d.zone!=this)throw new Error("A task can only be run in the zone of creation! (Creation: "+(d.zone||Ie).name+"; Execution: "+this.name+")");if(d.state===Ee&&(d.type===ze||d.type===j))return;const J=d.state!=R;J&&d._transitionTo(R,ue),d.runCount++;const Me=gt;gt=d,Ne={parent:Ne,zone:this};try{d.type==j&&d.data&&!d.data.isPeriodic&&(d.cancelFn=void 0);try{return this._zoneDelegate.invokeTask(this,d,g,k)}catch(S){if(this._zoneDelegate.handleError(this,S))throw S}}finally{d.state!==Ee&&d.state!==$&&(d.type==ze||d.data&&d.data.isPeriodic?J&&d._transitionTo(ue,R):(d.runCount=0,this._updateTaskCount(d,-1),J&&d._transitionTo(Ee,R,Ee))),Ne=Ne.parent,gt=Me}}scheduleTask(d){if(d.zone&&d.zone!==this){let k=this;for(;k;){if(k===d.zone)throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${d.zone.name}`);k=k.parent}}d._transitionTo(Q,Ee);const g=[];d._zoneDelegates=g,d._zone=this;try{d=this._zoneDelegate.scheduleTask(this,d)}catch(k){throw d._transitionTo($,Q,Ee),this._zoneDelegate.handleError(this,k),k}return d._zoneDelegates===g&&this._updateTaskCount(d,1),d.state==Q&&d._transitionTo(ue,Q),d}scheduleMicroTask(d,g,k,J){return this.scheduleTask(new z(se,d,g,k,J,void 0))}scheduleMacroTask(d,g,k,J,Me){return this.scheduleTask(new z(j,d,g,k,J,Me))}scheduleEventTask(d,g,k,J,Me){return this.scheduleTask(new z(ze,d,g,k,J,Me))}cancelTask(d){if(d.zone!=this)throw new Error("A task can only be cancelled in the zone of creation! (Creation: "+(d.zone||Ie).name+"; Execution: "+this.name+")");d._transitionTo(Ae,ue,R);try{this._zoneDelegate.cancelTask(this,d)}catch(g){throw d._transitionTo($,Ae),this._zoneDelegate.handleError(this,g),g}return this._updateTaskCount(d,-1),d._transitionTo(Ee,Ae),d.runCount=0,d}_updateTaskCount(d,g){const k=d._zoneDelegates;-1==g&&(d._zoneDelegates=null);for(let J=0;J<k.length;J++)k[J]._updateTaskCount(d.type,g)}}return T.__symbol__=I,T})();const ee={name:"",onHasTask:(T,W,d,g)=>T.hasTask(d,g),onScheduleTask:(T,W,d,g)=>T.scheduleTask(d,g),onInvokeTask:(T,W,d,g,k,J)=>T.invokeTask(d,g,k,J),onCancelTask:(T,W,d,g)=>T.cancelTask(d,g)};class B{constructor(W,d,g){this._taskCounts={microTask:0,macroTask:0,eventTask:0},this.zone=W,this._parentDelegate=d,this._forkZS=g&&(g&&g.onFork?g:d._forkZS),this._forkDlgt=g&&(g.onFork?d:d._forkDlgt),this._forkCurrZone=g&&(g.onFork?this.zone:d._forkCurrZone),this._interceptZS=g&&(g.onIntercept?g:d._interceptZS),this._interceptDlgt=g&&(g.onIntercept?d:d._interceptDlgt),this._interceptCurrZone=g&&(g.onIntercept?this.zone:d._interceptCurrZone),this._invokeZS=g&&(g.onInvoke?g:d._invokeZS),this._invokeDlgt=g&&(g.onInvoke?d:d._invokeDlgt),this._invokeCurrZone=g&&(g.onInvoke?this.zone:d._invokeCurrZone),this._handleErrorZS=g&&(g.onHandleError?g:d._handleErrorZS),this._handleErrorDlgt=g&&(g.onHandleError?d:d._handleErrorDlgt),this._handleErrorCurrZone=g&&(g.onHandleError?this.zone:d._handleErrorCurrZone),this._scheduleTaskZS=g&&(g.onScheduleTask?g:d._scheduleTaskZS),this._scheduleTaskDlgt=g&&(g.onScheduleTask?d:d._scheduleTaskDlgt),this._scheduleTaskCurrZone=g&&(g.onScheduleTask?this.zone:d._scheduleTaskCurrZone),this._invokeTaskZS=g&&(g.onInvokeTask?g:d._invokeTaskZS),this._invokeTaskDlgt=g&&(g.onInvokeTask?d:d._invokeTaskDlgt),this._invokeTaskCurrZone=g&&(g.onInvokeTask?this.zone:d._invokeTaskCurrZone),this._cancelTaskZS=g&&(g.onCancelTask?g:d._cancelTaskZS),this._cancelTaskDlgt=g&&(g.onCancelTask?d:d._cancelTaskDlgt),this._cancelTaskCurrZone=g&&(g.onCancelTask?this.zone:d._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;const k=g&&g.onHasTask;(k||d&&d._hasTaskZS)&&(this._hasTaskZS=k?g:ee,this._hasTaskDlgt=d,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=W,g.onScheduleTask||(this._scheduleTaskZS=ee,this._scheduleTaskDlgt=d,this._scheduleTaskCurrZone=this.zone),g.onInvokeTask||(this._invokeTaskZS=ee,this._invokeTaskDlgt=d,this._invokeTaskCurrZone=this.zone),g.onCancelTask||(this._cancelTaskZS=ee,this._cancelTaskDlgt=d,this._cancelTaskCurrZone=this.zone))}fork(W,d){return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,W,d):new U(W,d)}intercept(W,d,g){return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,W,d,g):d}invoke(W,d,g,k,J){return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,W,d,g,k,J):d.apply(g,k)}handleError(W,d){return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,W,d)}scheduleTask(W,d){let g=d;if(this._scheduleTaskZS)this._hasTaskZS&&g._zoneDelegates.push(this._hasTaskDlgtOwner),g=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,W,d),g||(g=d);else if(d.scheduleFn)d.scheduleFn(d);else{if(d.type!=se)throw new Error("Task is missing scheduleFn.");ne(d)}return g}invokeTask(W,d,g,k){return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,W,d,g,k):d.callback.apply(g,k)}cancelTask(W,d){let g;if(this._cancelTaskZS)g=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,W,d);else{if(!d.cancelFn)throw Error("Task is not cancelable");g=d.cancelFn(d)}return g}hasTask(W,d){try{this._hasTaskZS&&this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,W,d)}catch(g){this.handleError(W,g)}}_updateTaskCount(W,d){const g=this._taskCounts,k=g[W],J=g[W]=k+d;if(J<0)throw new Error("More tasks executed then were scheduled.");0!=k&&0!=J||this.hasTask(this.zone,{microTask:g.microTask>0,macroTask:g.macroTask>0,eventTask:g.eventTask>0,change:W})}}class z{constructor(W,d,g,k,J,Me){if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state="notScheduled",this.type=W,this.source=d,this.data=k,this.scheduleFn=J,this.cancelFn=Me,!g)throw new Error("callback is not defined");this.callback=g;const S=this;this.invoke=W===ze&&k&&k.useG?z.invokeTask:function(){return z.invokeTask.call(h,S,this,arguments)}}static invokeTask(W,d,g){W||(W=this),ke++;try{return W.runCount++,W.zone.runTask(W,d,g)}finally{1==ke&&G(),ke--}}get zone(){return this._zone}get state(){return this._state}cancelScheduleRequest(){this._transitionTo(Ee,Q)}_transitionTo(W,d,g){if(this._state!==d&&this._state!==g)throw new Error(`${this.type} '${this.source}': can not transition to '${W}', expecting state '${d}'${g?" or '"+g+"'":""}, was '${this._state}'.`);this._state=W,W==Ee&&(this._zoneDelegates=null)}toString(){return this.data&&typeof this.data.handleId<"u"?this.data.handleId.toString():Object.prototype.toString.call(this)}toJSON(){return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}}}const ge=I("setTimeout"),ce=I("Promise"),ae=I("then");let Ge,we=[],xe=!1;function Fe(T){if(Ge||h[ce]&&(Ge=h[ce].resolve(0)),Ge){let W=Ge[ae];W||(W=Ge.then),W.call(Ge,T)}else h[ge](T,0)}function ne(T){0===ke&&0===we.length&&Fe(G),T&&we.push(T)}function G(){if(!xe){for(xe=!0;we.length;){const T=we;we=[];for(let W=0;W<T.length;W++){const d=T[W];try{d.zone.runTask(d,null,null)}catch(g){be.onUnhandledError(g)}}}be.microtaskDrainDone(),xe=!1}}const Ie={name:"NO ZONE"},Ee="notScheduled",Q="scheduling",ue="scheduled",R="running",Ae="canceling",$="unknown",se="microTask",j="macroTask",ze="eventTask",Tt={},be={symbol:I,currentZoneFrame:()=>Ne,onUnhandledError:ve,microtaskDrainDone:ve,scheduleMicroTask:ne,showUncaughtError:()=>!U[I("ignoreConsoleErrorUncaughtError")],patchEventTarget:()=>[],patchOnProperties:ve,patchMethod:()=>ve,bindArguments:()=>[],patchThen:()=>ve,patchMacroTask:()=>ve,patchEventPrototype:()=>ve,isIEOrEdge:()=>!1,getGlobalObjects:()=>{},ObjectDefineProperty:()=>ve,ObjectGetOwnPropertyDescriptor:()=>{},ObjectCreate:()=>{},ArraySlice:()=>[],patchClass:()=>ve,wrapWithCurrentZone:()=>ve,filterProperties:()=>[],attachOriginToPatched:()=>ve,_redefineProperty:()=>ve,patchCallbacks:()=>ve,nativeScheduleMicroTask:Fe};let Ne={parent:null,zone:new U(null,null)},gt=null,ke=0;function ve(){}_("Zone","Zone"),h.Zone=U}(typeof window<"u"&&window||typeof self<"u"&&self||global);const Kt=Object.getOwnPropertyDescriptor,Kn=Object.defineProperty,Zn=Object.getPrototypeOf,rr=Object.create,He=Array.prototype.slice,et="addEventListener",bn="removeEventListener",Dn=Zone.__symbol__(et),ms=Zone.__symbol__(bn),wt="true",ft="false",te=Zone.__symbol__("");function Xn(h,v){return Zone.current.wrap(h,v)}function dn(h,v,x,_,C){return Zone.current.scheduleMacroTask(h,v,x,_,C)}const ye=Zone.__symbol__,Nn=typeof window<"u",tt=Nn?window:void 0,Be=Nn&&tt||"object"==typeof self&&self||global;function gs(h,v){for(let x=h.length-1;x>=0;x--)"function"==typeof h[x]&&(h[x]=Xn(h[x],v+"_"+x));return h}function Ve(h){return!h||!1!==h.writable&&!("function"==typeof h.get&&typeof h.set>"u")}const at=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,fn=!("nw"in Be)&&typeof Be.process<"u"&&"[object process]"==={}.toString.call(Be.process),Pn=!fn&&!at&&!(!Nn||!tt.HTMLElement),ir=typeof Be.process<"u"&&"[object process]"==={}.toString.call(Be.process)&&!at&&!(!Nn||!tt.HTMLElement),oe={},Xe=function(h){if(!(h=h||Be.event))return;let v=oe[h.type];v||(v=oe[h.type]=ye("ON_PROPERTY"+h.type));const x=this||h.target||Be,_=x[v];let C;if(Pn&&x===tt&&"error"===h.type){const I=h;C=_&&_.call(this,I.message,I.filename,I.lineno,I.colno,I.error),!0===C&&h.preventDefault()}else C=_&&_.apply(this,arguments),null!=C&&!C&&h.preventDefault();return C};function or(h,v,x){let _=Kt(h,v);if(!_&&x&&Kt(x,v)&&(_={enumerable:!0,configurable:!0}),!_||!_.configurable)return;const C=ye("on"+v+"patched");if(h.hasOwnProperty(C)&&h[C])return;delete _.writable,delete _.value;const I=_.get,M=_.set,U=v.slice(2);let ee=oe[U];ee||(ee=oe[U]=ye("ON_PROPERTY"+U)),_.set=function(B){let z=this;!z&&h===Be&&(z=Be),z&&("function"==typeof z[ee]&&z.removeEventListener(U,Xe),M&&M.call(z,null),z[ee]=B,"function"==typeof B&&z.addEventListener(U,Xe,!1))},_.get=function(){let B=this;if(!B&&h===Be&&(B=Be),!B)return null;const z=B[ee];if(z)return z;if(I){let ge=I.call(this);if(ge)return _.set.call(this,ge),"function"==typeof B.removeAttribute&&B.removeAttribute(v),ge}return null},Kn(h,v,_),h[C]=!0}function ar(h,v,x){if(v)for(let _=0;_<v.length;_++)or(h,"on"+v[_],x);else{const _=[];for(const C in h)"on"==C.slice(0,2)&&_.push(C);for(let C=0;C<_.length;C++)or(h,_[C],x)}}const mt=ye("originalInstance");function Ft(h){const v=Be[h];if(!v)return;Be[ye(h)]=v,Be[h]=function(){const C=gs(arguments,h);switch(C.length){case 0:this[mt]=new v;break;case 1:this[mt]=new v(C[0]);break;case 2:this[mt]=new v(C[0],C[1]);break;case 3:this[mt]=new v(C[0],C[1],C[2]);break;case 4:this[mt]=new v(C[0],C[1],C[2],C[3]);break;default:throw new Error("Arg list too long.")}},Nt(Be[h],v);const x=new v(function(){});let _;for(_ in x)"XMLHttpRequest"===h&&"responseBlob"===_||function(C){"function"==typeof x[C]?Be[h].prototype[C]=function(){return this[mt][C].apply(this[mt],arguments)}:Kn(Be[h].prototype,C,{set:function(I){"function"==typeof I?(this[mt][C]=Xn(I,h+"."+C),Nt(this[mt][C],I)):this[mt][C]=I},get:function(){return this[mt][C]}})}(_);for(_ in v)"prototype"!==_&&v.hasOwnProperty(_)&&(Be[h][_]=v[_])}function Ot(h,v,x){let _=h;for(;_&&!_.hasOwnProperty(v);)_=Zn(_);!_&&h[v]&&(_=h);const C=ye(v);let I=null;if(_&&(!(I=_[C])||!_.hasOwnProperty(C))&&(I=_[C]=_[v],Ve(_&&Kt(_,v)))){const U=x(I,C,v);_[v]=function(){return U(this,arguments)},Nt(_[v],I)}return I}function ai(h,v,x){let _=null;function C(I){const M=I.data;return M.args[M.cbIdx]=function(){I.invoke.apply(this,arguments)},_.apply(M.target,M.args),I}_=Ot(h,v,I=>function(M,U){const ee=x(M,U);return ee.cbIdx>=0&&"function"==typeof U[ee.cbIdx]?dn(ee.name,U[ee.cbIdx],ee,C):I.apply(M,U)})}function Nt(h,v){h[ye("OriginalDelegate")]=v}let ur=!1,vs=!1;function ui(){if(ur)return vs;ur=!0;try{const h=tt.navigator.userAgent;(-1!==h.indexOf("MSIE ")||-1!==h.indexOf("Trident/")||-1!==h.indexOf("Edge/"))&&(vs=!0)}catch{}return vs}Zone.__load_patch("ZoneAwarePromise",(h,v,x)=>{const _=Object.getOwnPropertyDescriptor,C=Object.defineProperty,M=x.symbol,U=[],ee=!0===h[M("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],B=M("Promise"),z=M("then");x.onUnhandledError=S=>{if(x.showUncaughtError()){const D=S&&S.rejection;D?console.error("Unhandled Promise rejection:",D instanceof Error?D.message:D,"; Zone:",S.zone.name,"; Task:",S.task&&S.task.source,"; Value:",D,D instanceof Error?D.stack:void 0):console.error(S)}},x.microtaskDrainDone=()=>{for(;U.length;){const S=U.shift();try{S.zone.runGuarded(()=>{throw S.throwOriginal?S.rejection:S})}catch(D){ae(D)}}};const ce=M("unhandledPromiseRejectionHandler");function ae(S){x.onUnhandledError(S);try{const D=v[ce];"function"==typeof D&&D.call(this,S)}catch{}}function we(S){return S&&S.then}function xe(S){return S}function Ge(S){return d.reject(S)}const Fe=M("state"),ne=M("value"),G=M("finally"),Ie=M("parentPromiseValue"),Ee=M("parentPromiseState"),ue=null,R=!0,Ae=!1;function se(S,D){return w=>{try{be(S,D,w)}catch(N){be(S,!1,N)}}}const j=function(){let S=!1;return function(w){return function(){S||(S=!0,w.apply(null,arguments))}}},Tt=M("currentTaskTrace");function be(S,D,w){const N=j();if(S===w)throw new TypeError("Promise resolved with itself");if(S[Fe]===ue){let q=null;try{("object"==typeof w||"function"==typeof w)&&(q=w&&w.then)}catch(X){return N(()=>{be(S,!1,X)})(),S}if(D!==Ae&&w instanceof d&&w.hasOwnProperty(Fe)&&w.hasOwnProperty(ne)&&w[Fe]!==ue)gt(w),be(S,w[Fe],w[ne]);else if(D!==Ae&&"function"==typeof q)try{q.call(w,N(se(S,D)),N(se(S,!1)))}catch(X){N(()=>{be(S,!1,X)})()}else{S[Fe]=D;const X=S[ne];if(S[ne]=w,S[G]===G&&D===R&&(S[Fe]=S[Ee],S[ne]=S[Ie]),D===Ae&&w instanceof Error){const V=v.currentTask&&v.currentTask.data&&v.currentTask.data.__creationTrace__;V&&C(w,Tt,{configurable:!0,enumerable:!1,writable:!0,value:V})}for(let V=0;V<X.length;)ke(S,X[V++],X[V++],X[V++],X[V++]);if(0==X.length&&D==Ae){S[Fe]=0;let V=w;try{throw new Error("Uncaught (in promise): "+function I(S){return S&&S.toString===Object.prototype.toString?(S.constructor&&S.constructor.name||"")+": "+JSON.stringify(S):S?S.toString():Object.prototype.toString.call(S)}(w)+(w&&w.stack?"\n"+w.stack:""))}catch(Y){V=Y}ee&&(V.throwOriginal=!0),V.rejection=w,V.promise=S,V.zone=v.current,V.task=v.currentTask,U.push(V),x.scheduleMicroTask()}}}return S}const Ne=M("rejectionHandledHandler");function gt(S){if(0===S[Fe]){try{const D=v[Ne];D&&"function"==typeof D&&D.call(this,{rejection:S[ne],promise:S})}catch{}S[Fe]=Ae;for(let D=0;D<U.length;D++)S===U[D].promise&&U.splice(D,1)}}function ke(S,D,w,N,q){gt(S);const X=S[Fe],V=X?"function"==typeof N?N:xe:"function"==typeof q?q:Ge;D.scheduleMicroTask("Promise.then",()=>{try{const Y=S[ne],re=!!w&&G===w[G];re&&(w[Ie]=Y,w[Ee]=X);const ie=D.run(V,void 0,re&&V!==Ge&&V!==xe?[]:[Y]);be(w,!0,ie)}catch(Y){be(w,!1,Y)}},w)}const T=function(){},W=h.AggregateError;class d{static toString(){return"function ZoneAwarePromise() { [native code] }"}static resolve(D){return be(new this(null),R,D)}static reject(D){return be(new this(null),Ae,D)}static any(D){if(!D||"function"!=typeof D[Symbol.iterator])return Promise.reject(new W([],"All promises were rejected"));const w=[];let N=0;try{for(let V of D)N++,w.push(d.resolve(V))}catch{return Promise.reject(new W([],"All promises were rejected"))}if(0===N)return Promise.reject(new W([],"All promises were rejected"));let q=!1;const X=[];return new d((V,Y)=>{for(let re=0;re<w.length;re++)w[re].then(ie=>{q||(q=!0,V(ie))},ie=>{X.push(ie),N--,0===N&&(q=!0,Y(new W(X,"All promises were rejected")))})})}static race(D){let w,N,q=new this((Y,re)=>{w=Y,N=re});function X(Y){w(Y)}function V(Y){N(Y)}for(let Y of D)we(Y)||(Y=this.resolve(Y)),Y.then(X,V);return q}static all(D){return d.allWithCallback(D)}static allSettled(D){return(this&&this.prototype instanceof d?this:d).allWithCallback(D,{thenCallback:N=>({status:"fulfilled",value:N}),errorCallback:N=>({status:"rejected",reason:N})})}static allWithCallback(D,w){let N,q,X=new this((ie,Se)=>{N=ie,q=Se}),V=2,Y=0;const re=[];for(let ie of D){we(ie)||(ie=this.resolve(ie));const Se=Y;try{ie.then(Te=>{re[Se]=w?w.thenCallback(Te):Te,V--,0===V&&N(re)},Te=>{w?(re[Se]=w.errorCallback(Te),V--,0===V&&N(re)):q(Te)})}catch(Te){q(Te)}V++,Y++}return V-=2,0===V&&N(re),X}constructor(D){const w=this;if(!(w instanceof d))throw new Error("Must be an instanceof Promise.");w[Fe]=ue,w[ne]=[];try{const N=j();D&&D(N(se(w,R)),N(se(w,Ae)))}catch(N){be(w,!1,N)}}get[Symbol.toStringTag](){return"Promise"}get[Symbol.species](){return d}then(D,w){var N;let q=null===(N=this.constructor)||void 0===N?void 0:N[Symbol.species];(!q||"function"!=typeof q)&&(q=this.constructor||d);const X=new q(T),V=v.current;return this[Fe]==ue?this[ne].push(V,X,D,w):ke(this,V,X,D,w),X}catch(D){return this.then(null,D)}finally(D){var w;let N=null===(w=this.constructor)||void 0===w?void 0:w[Symbol.species];(!N||"function"!=typeof N)&&(N=d);const q=new N(T);q[G]=G;const X=v.current;return this[Fe]==ue?this[ne].push(X,q,D,D):ke(this,X,q,D,D),q}}d.resolve=d.resolve,d.reject=d.reject,d.race=d.race,d.all=d.all;const g=h[B]=h.Promise;h.Promise=d;const k=M("thenPatched");function J(S){const D=S.prototype,w=_(D,"then");if(w&&(!1===w.writable||!w.configurable))return;const N=D.then;D[z]=N,S.prototype.then=function(q,X){return new d((Y,re)=>{N.call(this,Y,re)}).then(q,X)},S[k]=!0}return x.patchThen=J,g&&(J(g),Ot(h,"fetch",S=>function Me(S){return function(D,w){let N=S.apply(D,w);if(N instanceof d)return N;let q=N.constructor;return q[k]||J(q),N}}(S))),Promise[v.__symbol__("uncaughtPromiseErrors")]=U,d}),Zone.__load_patch("toString",h=>{const v=Function.prototype.toString,x=ye("OriginalDelegate"),_=ye("Promise"),C=ye("Error"),I=function(){if("function"==typeof this){const B=this[x];if(B)return"function"==typeof B?v.call(B):Object.prototype.toString.call(B);if(this===Promise){const z=h[_];if(z)return v.call(z)}if(this===Error){const z=h[C];if(z)return v.call(z)}}return v.call(this)};I[x]=v,Function.prototype.toString=I;const M=Object.prototype.toString;Object.prototype.toString=function(){return"function"==typeof Promise&&this instanceof Promise?"[object Promise]":M.call(this)}});let Pt=!1;if(typeof window<"u")try{const h=Object.defineProperty({},"passive",{get:function(){Pt=!0}});window.addEventListener("test",h,h),window.removeEventListener("test",h,h)}catch{Pt=!1}const qo={useG:!0},Qe={},Es={},cr=new RegExp("^"+te+"(\\w+)(true|false)$"),Zt=ye("propagationStopped");function pr(h,v){const x=(v?v(h):h)+ft,_=(v?v(h):h)+wt,C=te+x,I=te+_;Qe[h]={},Qe[h][ft]=C,Qe[h][wt]=I}function li(h,v,x,_){const C=_&&_.add||et,I=_&&_.rm||bn,M=_&&_.listeners||"eventListeners",U=_&&_.rmAll||"removeAllListeners",ee=ye(C),B="."+C+":",ce=function(ne,G,Ie){if(ne.isRemoved)return;const Ee=ne.callback;let Q;"object"==typeof Ee&&Ee.handleEvent&&(ne.callback=R=>Ee.handleEvent(R),ne.originalDelegate=Ee);try{ne.invoke(ne,G,[Ie])}catch(R){Q=R}const ue=ne.options;return ue&&"object"==typeof ue&&ue.once&&G[I].call(G,Ie.type,ne.originalDelegate?ne.originalDelegate:ne.callback,ue),Q};function ae(ne,G,Ie){if(!(G=G||h.event))return;const Ee=ne||G.target||h,Q=Ee[Qe[G.type][Ie?wt:ft]];if(Q){const ue=[];if(1===Q.length){const R=ce(Q[0],Ee,G);R&&ue.push(R)}else{const R=Q.slice();for(let Ae=0;Ae<R.length&&(!G||!0!==G[Zt]);Ae++){const $=ce(R[Ae],Ee,G);$&&ue.push($)}}if(1===ue.length)throw ue[0];for(let R=0;R<ue.length;R++){const Ae=ue[R];v.nativeScheduleMicroTask(()=>{throw Ae})}}}const we=function(ne){return ae(this,ne,!1)},xe=function(ne){return ae(this,ne,!0)};function Ge(ne,G){if(!ne)return!1;let Ie=!0;G&&void 0!==G.useG&&(Ie=G.useG);const Ee=G&&G.vh;let Q=!0;G&&void 0!==G.chkDup&&(Q=G.chkDup);let ue=!1;G&&void 0!==G.rt&&(ue=G.rt);let R=ne;for(;R&&!R.hasOwnProperty(C);)R=Zn(R);if(!R&&ne[C]&&(R=ne),!R||R[ee])return!1;const Ae=G&&G.eventNameToString,$={},se=R[ee]=R[C],j=R[ye(I)]=R[I],ze=R[ye(M)]=R[M],Tt=R[ye(U)]=R[U];let be;function Ne(w,N){return!Pt&&"object"==typeof w&&w?!!w.capture:Pt&&N?"boolean"==typeof w?{capture:w,passive:!0}:w?"object"==typeof w&&!1!==w.passive?Object.assign(Object.assign({},w),{passive:!0}):w:{passive:!0}:w}G&&G.prepend&&(be=R[ye(G.prepend)]=R[G.prepend]);const d=Ie?function(w){if(!$.isExisting)return se.call($.target,$.eventName,$.capture?xe:we,$.options)}:function(w){return se.call($.target,$.eventName,w.invoke,$.options)},g=Ie?function(w){if(!w.isRemoved){const N=Qe[w.eventName];let q;N&&(q=N[w.capture?wt:ft]);const X=q&&w.target[q];if(X)for(let V=0;V<X.length;V++)if(X[V]===w){X.splice(V,1),w.isRemoved=!0,0===X.length&&(w.allRemoved=!0,w.target[q]=null);break}}if(w.allRemoved)return j.call(w.target,w.eventName,w.capture?xe:we,w.options)}:function(w){return j.call(w.target,w.eventName,w.invoke,w.options)},J=G&&G.diff?G.diff:function(w,N){const q=typeof N;return"function"===q&&w.callback===N||"object"===q&&w.originalDelegate===N},Me=Zone[ye("UNPATCHED_EVENTS")],S=h[ye("PASSIVE_EVENTS")],D=function(w,N,q,X,V=!1,Y=!1){return function(){const re=this||h;let ie=arguments[0];G&&G.transferEventName&&(ie=G.transferEventName(ie));let Se=arguments[1];if(!Se)return w.apply(this,arguments);if(fn&&"uncaughtException"===ie)return w.apply(this,arguments);let Te=!1;if("function"!=typeof Se){if(!Se.handleEvent)return w.apply(this,arguments);Te=!0}if(Ee&&!Ee(w,Se,re,arguments))return;const $t=Pt&&!!S&&-1!==S.indexOf(ie),vt=Ne(arguments[2],$t);if(Me)for(let ut=0;ut<Me.length;ut++)if(ie===Me[ut])return $t?w.call(re,ie,Se,vt):w.apply(this,arguments);const Ss=!!vt&&("boolean"==typeof vt||vt.capture),ws=!(!vt||"object"!=typeof vt)&&vt.once,Yn=Zone.current;let Ts=Qe[ie];Ts||(pr(ie,Ae),Ts=Qe[ie]);const fr=Ts[Ss?wt:ft];let qt,Vt=re[fr],xs=!1;if(Vt){if(xs=!0,Q)for(let ut=0;ut<Vt.length;ut++)if(J(Vt[ut],Se))return}else Vt=re[fr]=[];const mr=re.constructor.name,Mn=Es[mr];Mn&&(qt=Mn[ie]),qt||(qt=mr+N+(Ae?Ae(ie):ie)),$.options=vt,ws&&($.options.once=!1),$.target=re,$.capture=Ss,$.eventName=ie,$.isExisting=xs;const Ht=Ie?qo:void 0;Ht&&(Ht.taskData=$);const Oe=Yn.scheduleEventTask(qt,Se,Ht,q,X);return $.target=null,Ht&&(Ht.taskData=null),ws&&(vt.once=!0),!Pt&&"boolean"==typeof Oe.options||(Oe.options=vt),Oe.target=re,Oe.capture=Ss,Oe.eventName=ie,Te&&(Oe.originalDelegate=Se),Y?Vt.unshift(Oe):Vt.push(Oe),V?re:void 0}};return R[C]=D(se,B,d,g,ue),be&&(R.prependListener=D(be,".prependListener:",function(w){return be.call($.target,$.eventName,w.invoke,$.options)},g,ue,!0)),R[I]=function(){const w=this||h;let N=arguments[0];G&&G.transferEventName&&(N=G.transferEventName(N));const q=arguments[2],X=!!q&&("boolean"==typeof q||q.capture),V=arguments[1];if(!V)return j.apply(this,arguments);if(Ee&&!Ee(j,V,w,arguments))return;const Y=Qe[N];let re;Y&&(re=Y[X?wt:ft]);const ie=re&&w[re];if(ie)for(let Se=0;Se<ie.length;Se++){const Te=ie[Se];if(J(Te,V))return ie.splice(Se,1),Te.isRemoved=!0,0===ie.length&&(Te.allRemoved=!0,w[re]=null,"string"==typeof N)&&(w[te+"ON_PROPERTY"+N]=null),Te.zone.cancelTask(Te),ue?w:void 0}return j.apply(this,arguments)},R[M]=function(){const w=this||h;let N=arguments[0];G&&G.transferEventName&&(N=G.transferEventName(N));const q=[],X=Xt(w,Ae?Ae(N):N);for(let V=0;V<X.length;V++){const Y=X[V];q.push(Y.originalDelegate?Y.originalDelegate:Y.callback)}return q},R[U]=function(){const w=this||h;let N=arguments[0];if(N){G&&G.transferEventName&&(N=G.transferEventName(N));const q=Qe[N];if(q){const Y=w[q[ft]],re=w[q[wt]];if(Y){const ie=Y.slice();for(let Se=0;Se<ie.length;Se++){const Te=ie[Se];this[I].call(this,N,Te.originalDelegate?Te.originalDelegate:Te.callback,Te.options)}}if(re){const ie=re.slice();for(let Se=0;Se<ie.length;Se++){const Te=ie[Se];this[I].call(this,N,Te.originalDelegate?Te.originalDelegate:Te.callback,Te.options)}}}}else{const q=Object.keys(w);for(let X=0;X<q.length;X++){const Y=cr.exec(q[X]);let re=Y&&Y[1];re&&"removeListener"!==re&&this[U].call(this,re)}this[U].call(this,"removeListener")}if(ue)return this},Nt(R[C],se),Nt(R[I],j),Tt&&Nt(R[U],Tt),ze&&Nt(R[M],ze),!0}let Fe=[];for(let ne=0;ne<x.length;ne++)Fe[ne]=Ge(x[ne],_);return Fe}function Xt(h,v){if(!v){const I=[];for(let M in h){const U=cr.exec(M);let ee=U&&U[1];if(ee&&(!v||ee===v)){const B=h[M];if(B)for(let z=0;z<B.length;z++)I.push(B[z])}}return I}let x=Qe[v];x||(pr(v),x=Qe[v]);const _=h[x[ft]],C=h[x[wt]];return _?C?_.concat(C):_.slice():C?C.slice():[]}function hr(h,v){const x=h.Event;x&&x.prototype&&v.patchMethod(x.prototype,"stopImmediatePropagation",_=>function(C,I){C[Zt]=!0,_&&_.apply(C,I)})}function ci(h,v,x,_,C){const I=Zone.__symbol__(_);if(v[I])return;const M=v[I]=v[_];v[_]=function(U,ee,B){return ee&&ee.prototype&&C.forEach(function(z){const ge=`${x}.${_}::`+z,ce=ee.prototype;try{if(ce.hasOwnProperty(z)){const ae=h.ObjectGetOwnPropertyDescriptor(ce,z);ae&&ae.value?(ae.value=h.wrapWithCurrentZone(ae.value,ge),h._redefineProperty(ee.prototype,z,ae)):ce[z]&&(ce[z]=h.wrapWithCurrentZone(ce[z],ge))}else ce[z]&&(ce[z]=h.wrapWithCurrentZone(ce[z],ge))}catch{}}),M.call(v,U,ee,B)},h.attachOriginToPatched(v[_],M)}function _s(h,v,x){if(!x||0===x.length)return v;const _=x.filter(I=>I.target===h);if(!_||0===_.length)return v;const C=_[0].ignoreProperties;return v.filter(I=>-1===C.indexOf(I))}function ys(h,v,x,_){h&&ar(h,_s(h,v,x),_)}function kn(h){return Object.getOwnPropertyNames(h).filter(v=>v.startsWith("on")&&v.length>2).map(v=>v.substring(2))}Zone.__load_patch("util",(h,v,x)=>{const _=kn(h);x.patchOnProperties=ar,x.patchMethod=Ot,x.bindArguments=gs,x.patchMacroTask=ai;const C=v.__symbol__("BLACK_LISTED_EVENTS"),I=v.__symbol__("UNPATCHED_EVENTS");h[I]&&(h[C]=h[I]),h[C]&&(v[C]=v[I]=h[C]),x.patchEventPrototype=hr,x.patchEventTarget=li,x.isIEOrEdge=ui,x.ObjectDefineProperty=Kn,x.ObjectGetOwnPropertyDescriptor=Kt,x.ObjectCreate=rr,x.ArraySlice=He,x.patchClass=Ft,x.wrapWithCurrentZone=Xn,x.filterProperties=_s,x.attachOriginToPatched=Nt,x._redefineProperty=Object.defineProperty,x.patchCallbacks=ci,x.getGlobalObjects=()=>({globalSources:Es,zoneSymbolEventNames:Qe,eventNames:_,isBrowser:Pn,isMix:ir,isNode:fn,TRUE_STR:wt,FALSE_STR:ft,ZONE_SYMBOL_PREFIX:te,ADD_EVENT_LISTENER_STR:et,REMOVE_EVENT_LISTENER_STR:bn})});const Ln=ye("zoneTask");function mn(h,v,x,_){let C=null,I=null;x+=_;const M={};function U(B){const z=B.data;return z.args[0]=function(){return B.invoke.apply(this,arguments)},z.handleId=C.apply(h,z.args),B}function ee(B){return I.call(h,B.data.handleId)}C=Ot(h,v+=_,B=>function(z,ge){if("function"==typeof ge[0]){const ce={isPeriodic:"Interval"===_,delay:"Timeout"===_||"Interval"===_?ge[1]||0:void 0,args:ge},ae=ge[0];ge[0]=function(){try{return ae.apply(this,arguments)}finally{ce.isPeriodic||("number"==typeof ce.handleId?delete M[ce.handleId]:ce.handleId&&(ce.handleId[Ln]=null))}};const we=dn(v,ge[0],ce,U,ee);if(!we)return we;const xe=we.data.handleId;return"number"==typeof xe?M[xe]=we:xe&&(xe[Ln]=we),xe&&xe.ref&&xe.unref&&"function"==typeof xe.ref&&"function"==typeof xe.unref&&(we.ref=xe.ref.bind(xe),we.unref=xe.unref.bind(xe)),"number"==typeof xe||xe?xe:we}return B.apply(h,ge)}),I=Ot(h,x,B=>function(z,ge){const ce=ge[0];let ae;"number"==typeof ce?ae=M[ce]:(ae=ce&&ce[Ln],ae||(ae=ce)),ae&&"string"==typeof ae.type?"notScheduled"!==ae.state&&(ae.cancelFn&&ae.data.isPeriodic||0===ae.runCount)&&("number"==typeof ce?delete M[ce]:ce&&(ce[Ln]=null),ae.zone.cancelTask(ae)):B.apply(h,ge)})}Zone.__load_patch("legacy",h=>{const v=h[Zone.__symbol__("legacyPatch")];v&&v()}),Zone.__load_patch("queueMicrotask",(h,v,x)=>{x.patchMethod(h,"queueMicrotask",_=>function(C,I){v.current.scheduleMicroTask("queueMicrotask",I[0])})}),Zone.__load_patch("timers",h=>{const v="set",x="clear";mn(h,v,x,"Timeout"),mn(h,v,x,"Interval"),mn(h,v,x,"Immediate")}),Zone.__load_patch("requestAnimationFrame",h=>{mn(h,"request","cancel","AnimationFrame"),mn(h,"mozRequest","mozCancel","AnimationFrame"),mn(h,"webkitRequest","webkitCancel","AnimationFrame")}),Zone.__load_patch("blocking",(h,v)=>{const x=["alert","prompt","confirm"];for(let _=0;_<x.length;_++)Ot(h,x[_],(I,M,U)=>function(ee,B){return v.current.run(I,h,B,U)})}),Zone.__load_patch("EventTarget",(h,v,x)=>{(function di(h,v){v.patchEventPrototype(h,v)})(h,x),function hi(h,v){if(Zone[v.symbol("patchEventTarget")])return;const{eventNames:x,zoneSymbolEventNames:_,TRUE_STR:C,FALSE_STR:I,ZONE_SYMBOL_PREFIX:M}=v.getGlobalObjects();for(let ee=0;ee<x.length;ee++){const B=x[ee],ce=M+(B+I),ae=M+(B+C);_[B]={},_[B][I]=ce,_[B][C]=ae}const U=h.EventTarget;U&&U.prototype&&v.patchEventTarget(h,v,[U&&U.prototype])}(h,x);const _=h.XMLHttpRequestEventTarget;_&&_.prototype&&x.patchEventTarget(h,x,[_.prototype])}),Zone.__load_patch("MutationObserver",(h,v,x)=>{Ft("MutationObserver"),Ft("WebKitMutationObserver")}),Zone.__load_patch("IntersectionObserver",(h,v,x)=>{Ft("IntersectionObserver")}),Zone.__load_patch("FileReader",(h,v,x)=>{Ft("FileReader")}),Zone.__load_patch("on_property",(h,v,x)=>{!function dr(h,v){if(fn&&!ir||Zone[h.symbol("patchEvents")])return;const x=v.__Zone_ignore_on_properties;let _=[];if(Pn){const C=window;_=_.concat(["Document","SVGElement","Element","HTMLElement","HTMLBodyElement","HTMLMediaElement","HTMLFrameSetElement","HTMLFrameElement","HTMLIFrameElement","HTMLMarqueeElement","Worker"]);const I=function lr(){try{const h=tt.navigator.userAgent;if(-1!==h.indexOf("MSIE ")||-1!==h.indexOf("Trident/"))return!0}catch{}return!1}()?[{target:C,ignoreProperties:["error"]}]:[];ys(C,kn(C),x&&x.concat(I),Zn(C))}_=_.concat(["XMLHttpRequest","XMLHttpRequestEventTarget","IDBIndex","IDBRequest","IDBOpenDBRequest","IDBDatabase","IDBTransaction","IDBCursor","WebSocket"]);for(let C=0;C<_.length;C++){const I=v[_[C]];I&&I.prototype&&ys(I.prototype,kn(I.prototype),x)}}(x,h)}),Zone.__load_patch("customElements",(h,v,x)=>{!function pi(h,v){const{isBrowser:x,isMix:_}=v.getGlobalObjects();(x||_)&&h.customElements&&"customElements"in h&&v.patchCallbacks(v,h.customElements,"customElements","define",["connectedCallback","disconnectedCallback","adoptedCallback","attributeChangedCallback"])}(h,x)}),Zone.__load_patch("XHR",(h,v)=>{!function ee(B){const z=B.XMLHttpRequest;if(!z)return;const ge=z.prototype;let ae=ge[Dn],we=ge[ms];if(!ae){const $=B.XMLHttpRequestEventTarget;if($){const se=$.prototype;ae=se[Dn],we=se[ms]}}const xe="readystatechange",Ge="scheduled";function Fe($){const se=$.data,j=se.target;j[I]=!1,j[U]=!1;const ze=j[C];ae||(ae=j[Dn],we=j[ms]),ze&&we.call(j,xe,ze);const Tt=j[C]=()=>{if(j.readyState===j.DONE)if(!se.aborted&&j[I]&&$.state===Ge){const Ne=j[v.__symbol__("loadfalse")];if(0!==j.status&&Ne&&Ne.length>0){const gt=$.invoke;$.invoke=function(){const ke=j[v.__symbol__("loadfalse")];for(let ve=0;ve<ke.length;ve++)ke[ve]===$&&ke.splice(ve,1);!se.aborted&&$.state===Ge&&gt.call($)},Ne.push($)}else $.invoke()}else!se.aborted&&!1===j[I]&&(j[U]=!0)};return ae.call(j,xe,Tt),j[x]||(j[x]=$),R.apply(j,se.args),j[I]=!0,$}function ne(){}function G($){const se=$.data;return se.aborted=!0,Ae.apply(se.target,se.args)}const Ie=Ot(ge,"open",()=>function($,se){return $[_]=0==se[2],$[M]=se[1],Ie.apply($,se)}),Q=ye("fetchTaskAborting"),ue=ye("fetchTaskScheduling"),R=Ot(ge,"send",()=>function($,se){if(!0===v.current[ue]||$[_])return R.apply($,se);{const j={target:$,url:$[M],isPeriodic:!1,args:se,aborted:!1},ze=dn("XMLHttpRequest.send",ne,j,Fe,G);$&&!0===$[U]&&!j.aborted&&ze.state===Ge&&ze.invoke()}}),Ae=Ot(ge,"abort",()=>function($,se){const j=function ce($){return $[x]}($);if(j&&"string"==typeof j.type){if(null==j.cancelFn||j.data&&j.data.aborted)return;j.zone.cancelTask(j)}else if(!0===v.current[Q])return Ae.apply($,se)})}(h);const x=ye("xhrTask"),_=ye("xhrSync"),C=ye("xhrListener"),I=ye("xhrScheduled"),M=ye("xhrURL"),U=ye("xhrErrorBeforeScheduled")}),Zone.__load_patch("geolocation",h=>{h.navigator&&h.navigator.geolocation&&function oi(h,v){const x=h.constructor.name;for(let _=0;_<v.length;_++){const C=v[_],I=h[C];if(I){if(!Ve(Kt(h,C)))continue;h[C]=(U=>{const ee=function(){return U.apply(this,gs(arguments,x+"."+C))};return Nt(ee,U),ee})(I)}}}(h.navigator.geolocation,["getCurrentPosition","watchPosition"])}),Zone.__load_patch("PromiseRejectionEvent",(h,v)=>{function x(_){return function(C){Xt(h,_).forEach(M=>{const U=h.PromiseRejectionEvent;if(U){const ee=new U(_,{promise:C.promise,reason:C.rejection});M.invoke(ee)}})}}h.PromiseRejectionEvent&&(v[ye("unhandledPromiseRejectionHandler")]=x("unhandledrejection"),v[ye("rejectionHandledHandler")]=x("rejectionhandled"))})}},Kt=>{Kt(Kt.s=4663)}]);